C++对象模型:
    1) nonstatic data members放在class object内;
    2) static 和 nostatic function members放在class object外
    3） virtual function放在virtual table中;
        3.1) 每一个class object有一个指针vptr指向virtual table;
        3.1) class object的vptr的设置和重置由constructor, destructor, copy assignment来完成.
    4) 每一个派生类的对象的运行时类型(type_info object)由virtual table被指出来, 通常放在表格的第一个slot处.

指针类型: 会教导编译器如何解释某个特定地址中的内存内容及其大小;

针对构造函数, 编译器都做了什么?

Chapter2: 构造函数语义学;
编译器对构造函数的影响:
    1. "带有Default Constructor"的Member Clas Object:
        1) 当类中有member object且member object有默认的构造函数, 如果没有显示定义一个默认构造函数, 
            则编译器会生成一个默认的构造函数并在构造函数中调用member object的默认构造函数;
            编译器生成的默认构造函数是"nontrivial";
        2) 当类中有member object且member object有默认的构造函数, 如果有显示定义一个默认的构造函数, 但是没有对member object做初始化(没有调用对应的构造函数);
            则编译器会扩充此默认构造函数, 在user code之前按照member object的声明顺序依次调用对应的构造函数;
        
    2. "带有 Default Constructor"的Base Class:
        1) 如果派生类没有任何构造函数, 但是对应的基类有默认的构造函数:
            1.1) 那么编译器会自动生成一个默认的构造函数, 并调用基类的默认构造函数;
    3. "带有一个Virtual Function"的Class
        3.1) class 声明(或者继承)一个virtual function;
        3.2) class 派生子一个继承串链, 其中有一个或更多的virtual base class;

        3.3) 在3.1和3.2的情况下:
            3.3.1) 一个virtual function table(在 cfront 中被称为vtbl)会被编译器产生出来, 内放class
                    的 virtual function地址;
            3.3.2) 在每一个class object中, 一个额外的pointer member(也就是vptr)会被编译器合成出来, 内含
                    相关的class vtbl的地址;
        
    4. "带有一个Virtual Base Class"的Class
        4.1) 编译器会在每一个constructor中安插"允许每一个virtual base class的执行器存取操作"的代码:
            使用一个指针指向虚基类的成员变量;
        NOTE:
            1) 任何class如果没有定义default constructor, 就会被合成出一个来:
                这句话是错误的, 因为当其有基类或者成员变量中有nonstatic class object, 或者由虚基类或者有虚函数时, 才会生成default constructor;
            2) 编译器合成出来的default constructor会明确设定"class内每一个data member的默认值":
                只对non static class object member做初始化, 其他如int, double类型的成员变量则不会做初始化;
    

复制构造函数:
    Copy Constructor的建构操作: 调用复制构造函数的情况:
        1) 使用一个object来初始化另一个object:
            class X{...}
            X x;
            X xx = x;
        2) 以object作为返回值:
            X foo_bar(){X xx; return xx;}
        3) 以object作为参数:
            extern void foo(X x){};


    Default Memberwise Initialization:
        1) 复制构造函数只有在必要时才会被编译器自动生成, 生成nontrivial 版本的copy constructor;
        2) 是否为nontrivial constructor依赖于class声明是否体现Bitwise Copy Semantics(位逐次拷贝);
    
    Bitwise Copy Semantics(满足如下4点中的一个就不具备Bitwise Copy Semantics):
        1) 当class内含一个member object而后者的class声明有一个copy constructor时(不论是被class设计者明确的声明
            , 或者被编译器合成);
        2) 当class继承自一个base class而后者存在有一个copy constructor时(不论是被明确声明或者被合成而得);
        3) 当class声明了一个或多个virtual functions时;
        4) 当class派生自一个继承串链, 其中有一个或多个virtual base classes时;

    重新设定Virtual Table的指针:
        编译器在编译期间做的两个程序扩张操作:
            1) 增加一个virtual function table(vtbl), 内含美好一个有作用的virtual function地址;
            2) 将一个纸箱virtual function table的指针(vptr), 安插在每一个class object内;
        当拥有virtual member function的base class通过derived class初始化时, 会导致bitwise copy semantics失效;

程序转换语义学:
    明确的初始化操作:
        编译器在编译期间会安插调用构造函数的语义:
            X x1(x0) ==> X x1; x1.X::X(x0);
    参数的初始化操作:
        编译器会通过临时变量对参数做初始化动作:
            void foo(X x0);
            X xx;
            foo(xx);
            ==>
            // 编译器生成临时对象;
            X __temp0;
            // 编译器调用copy constructor
            __temp0.X::X(xx);
            // 重新改写函数调用操作, 从而使用上述临时对象;
            foo(__temp0);
    返回值的初始化操作:
        1) 对函数加上一个额外参数, 类型是class object的一个reference, 这个参数将用来放置
            被"拷贝建构(copy constructed)"而得的返回值;
        2) 在return指令前安插一个copy constructor调用操作, 以便将欲传回的object的内容
            当做上述新增参数的初始值;
        3) 改写函数, 是函数不返回任何信息;
        X bar(){
            X xx;
            // 处理xx ...
            return xx;
        }
        ==> 
        void
        bar(X & __result){
            X xx;
            //编译器生成的调用default constructor的操作;
            xx.X::X();

            //  ...处理xx

            // 编译器产生的调用copy constructor的操作;
            __result.X::XX(xx);

            return;
        }

        对于函数指针的调用的处理与上述相似, 如下:
            X (*pf)(); pf = bar ==> void (*pf)(X &); pf = bar;
        
    在使用者层面做优化:
        1) 对于返回某个class object的函数, 由程序员专门实现一个函数, 使实际的返回值是通过参数计算得到的;
    在编译器层面做优化:
        1.) 编译器自己做优化,例如NRV(Named Return Value):
        X bar(){
            X xx;
            // .. 处理xx
            return xx;
        }
        ==> 
        void bar(X & __result){
            // Default constructor被调用;
            // C++伪代码;
            __result.X::X();
            // ...直接处理__result
            return;
        }
        2.) 编译器对empty virtual base class不做任何处理, 也不使用一个指针来在derived class中表示empty virtual base class是一个空的class, 从而节省derived class所占用的空间;
        

        
    

NOTE:
如果default copy constructor没有被声明的话, 会被视为nontrivial;
    处理 Virtual Base Class Subobject:
        NOTE: "derived class object中的virtual base class subobject位置"在执行期间就准备妥当;

何时使用member initialization list(初始化次序是member成员被声明的次序):
    1) 当初始化一个reference member时;
    2) 当初始化一个const member时;
    3) 当调用一个base class的constructor, 而它有一组参数时;
    4) 当调用一个member class的constructor, 而它有一组参数时;

    编译器会把生成的initialization list中的初始化代码会放在构造函数的explicit user code之前;

Chapter3:
Data语义学(The Semantics of Data): 主要关注数据类型在内存中占有的字节大小;
    class 类型的大小所受的影响:
        1) 语言本身所造成的额外负担:
            由于语言支持virtual base classes时, 就会导致一些额外的负担 -- 指针, 指针体现在derived class中, 指针
            指向virtual base class subobject或者相关的表格; 一般一个指针占用4个字节(32bit);
        2) 编译器对于特殊情况所提供的优化处理;
        3) Alignment的限制: 在大部分机器上, 群聚的结构体大小会受到alignment的限制, 使它们能够更有效率的在内存中被存取;
            简单说, 就是把数值调整到某个数字的整数倍, 在32为机器上, 通常alignment为4 bytes(32位), 以使bus的"运输量"达到最高效率;


class继承示例.png:
    class X {};
    class Y: public virtual X {};
    class Z: public virtual X {};
    class A: public, public Z {};
NOTE:
    一个virtual base class subobject只会在derived class中存在一份实体, 不管它在class继承体系中出现多少次;
    一个class的大小与其包含的member object和编译器的优化方式有直接的关系;

3.1) Data Member的绑定(The Bindig of a Data Member):
    C++的两种防御性程序设计风格:
        1) 把所有的data members 放在class声明开头处, 以确保正确的绑定;
        2) 把所有的inline functions, 不管大小都放在class声明之外;
        3) 把所有nested type声明放在class的开头处;

3.2) Data Member的布局(Data Member Layout)
    NOTE: 在同一个access section中(private, public, protected), members的排列只需要符合"较晚出现的members在class object中有较高的地址";
    判断class中哪一个成员变量被声明在前, 哪一个成员变量被声明在后:
    template<class class_type,
            class data_type1,
            class data_type2>
    char *
    access_order(
        data_type1 class_type::*mem1,
        data_type2 class_type::*mem2
    ){
        assert(mem1 != mem2);
        return mem1 < mem2 
            ? "member 1 occurrs first"
            : "member 2 occurrs first"
    }

    调用方式:
        access_order(*Point3d::z, &Point3d::y);
        调用时, class_type会被绑定为Point3d, data_type1会被绑定为float, data_type2会被绑定为float;

3.3) Data Member的存取成本:
    3.3.1) Static Data Member 的存取:
        无论是通过对象来访问, 还是通过指针来访问, 还是通过class 名称来访问, 编译器所处理之后的访问方式都是相同的, 因为每一个类中的static member都被放在全局的同一个data segment中;
        如果由多个class声明了相同名称的static data member, 则会对每一个class的static data member声明不同的名称以区别开来;
    3.3.2) Nonstatic Data Member存取成本:
        对一个nonstatic data member进行存取操作, 编译器会在class object的起始地址加上data member的偏移量(offset):
        origin._y = 0.0 ==> &origin + (&Point3d::_y - 1);
        -1操作是因为指向data member的指针, offset总是会被加上1, 以区分:
            1) 一个指向data member的指针,用于指出class的第一个member;
            2) 一个指向data member的指针, 没有指出任何member;
        
        对非虚拟继承的成员变量的访问成本, 与访问一个C struct member或一个noderived class的member是一样的;
3.4) "继承"与Data Member
    3.4.1) 只要继承不要多太(Inheritance without Polymorphism):
        把两个不相干的class凑成一起"type/subtype",会出现如下错误:
            1) 会重复设计一些相同操作的函数;
            2) 一个class分为两层, 可能会导致"表现class体系之抽象化"而膨胀所需要的空间;
        NOTE:
            出现在derived class中的base class subobject有其完整原样性;
    3.4.2) 加上多太(Adding Polymorphism):
        对于vptr的处理:
        有的编译器把vptr放在object尾端;
        有的编译器把vprt放在object的起头处:
            1) 优点: 会简化访问成员变量的offset的计算;
            2) 缺点: 丧失了C语言的兼容性;
    3.4.3) 多重继承(Multiple Inheritance):
        示例: class X: public class Y, public class Z{}
        X x; Y y; Z z;
        Z * z = &x;
        编译器会做如下转换:
        z = (Z*)(((char*)&x) + sizeof(Y))
        X * x;
        Z * z;
        此时赋值操作z = x需要做一次判断, 而不能简单的去做赋值:
        z = x ? (Z*)(((char*)&x) + sizeof(Y)) : 0;
        存取member只是一个简单的offset运算, 不管是经由一个指针, 一个reference或者是一个object来存取;
    3.4.4) 虚拟继承(Virtual Inheritance):
        对于共享的subobject的处理有多种不同的方式:
            3.4.4.1) 以指针指向base class的实现模型;
            3.4.4.2) 在virtual function table中放置virtual base class的offset;
3.5) 对象成员的存取效率(Object Member Efficiency)
    1) 需要根据实际测试接过来决定哪一种方式效率比较高, 不能仅凭直觉判断或者猜测;
3.6) 指向Data Members的指针(Pointer to Data Members)的用处:
    1) 可以通过指向成员的指针来调查class members的底层布局;
    2) 可以用来决定class中access sections的次序;
3.7) "指向Members的指针"的效率问题:
    1) 

        


Chapter4:
NOTE:
	static member function不能使用const进行修饰, Eg:
	class Demo{
		public:
		static void display()const{}// 是错误的
	}

	4.1 Member的各种调用方式:
		4.1.1) Nonstatic Member Function(非静态成员函数):
			4.1.1.1) nonstatic member function 的调用效率和nonmember function相同;
				nonstatic member function的调用被编译器转化为普通函数的调用, 同时添加一个参数用来表示指向对象的指针this;
				并且函数如果返回一个对象时, 把函数转化为void, 并且把返回值通过参数引用的形式得到;
			4.1.1.2) 名称的特殊处理(Name Mangling)
				一般而言, member的名称前面会被加上class名称, 形成唯一的命名,主要是为了区别派生过程中基类和派生类中同名成员变量或者函数的区别:
				Eg: class bar{public: int value;...}; ==> ival_3Bar;
		4.1.2) Virtual Member Function(虚拟成员函数)
			如果normalize()是一个virtual member function(), 则ptr->normalize()会被转化如下:
			(*ptr->vptr[1])(ptr);
			明确的调用操作(explicitly invocation)会压制虚拟机制
			Point3d Point3d::normalize() const{
				register flaot mag = magnitude();
				return Point3d(_x/mag, _y/mag, _z/mag);
			}
			当函数normalize和函数magnitude被声明为virtual, 由于在调用normalize时, 
			编译器已经明确知道要调用Point3类型的对象的virtual函数normalize, 因此在内部调用magnitude时
			就不需要继续通过多太的形式调用, 而是可以明确压制编译器的多态机制, 直接调用Point3d中的magnitude函数;
			register float mag = Point3d::magnitude();
		4.1.3) Static Member Functions(静态成员函数)
			static member functions的特性:
				1) 没有this指针;
				2) 不能直接存取class中的nonstatic members;
				3) 不能够被声明为const, volatile或者virtual;
				4) 不需要经由class object被调用;
				5) 可以成为一个callback函数, 可以应用在线程(threads);
	4.2) Virtual Member Functions(虚拟成员函数):
		NOTE: 多太: 以一个public base class的指针(或reference), 寻址出一个derived class object;
			4.2.1) 编译器对于单继承的多太的支持:
				1) 在每一个多态的class object上增加两个members:
					1.1) 一个字符串或者数字, 表示class的类型;
					1.2) 一个指针, 指向某表格, 表格中带有程序的virtual function的执行期间地址;
				2) 在每一个class object中安插一个有编译器内部产生的指针, 指向表格;
				3) 每一个virtual function都被编译器指派一个表格的索引值(表格的下标);
				4) 一个class只有一个virtual table, 每一个table包含对应的class object中所有active virtual functions函数实体的地址, 
					这些active virtual functions包括:
					4.1) class所定义的函数实体,可能会改写(overriding)一个可能存在的base class virtual function 函数实体;
					4.2) 继承自base class的函数实体, 这是在derived class中决定不改写的virtual function时才会出现的情况;
					4.3) 一个pure_virtual_called()函数实体, 既可以扮演pure virtual function的空间保卫者角色, 也可以当做执行期异常处理函数;
			4.2.2) 编译器对多重继承的支持:
				1) 经由指向"第二或后继之base class"的指针(或reference)来调用derived class virtual function.
				NOTE:
					thunk技术: 以适当的offset值调整this指针, 调到virtual function去;
				2) 多重继承中第二或后继的base class对virtual function的支持的情况:
					2.1) 通过一个"指向第二个base class"的指针, 调用derived class virtual function;
						Base2 * ptr = new Derived;
						// 调用derived::~Derived
						// ptr 必须被向后调整sizeof(Base1)个bytes, 从而指向Derived对象的起始地址;
						delete ptr;
					2.2) 通过一个"指向derived class"的指针, 调用第二个base class中一个继承而来的virtual function;
						derived class指针必须再次调整, 以指向第二个base subobject;
					2.3) 允许一个virtual function的返回值类型有所变化, 可能是base type, 也可能是publicly derived type;
			4.2.3) 虚拟继承下的Virtual Functions:
				NOTE: 不要在一个virtual base class中声明nonstatic data members;
	4.4) 指向Member Function的指针
			4.4.1) 支持"指向Virtual Member Functions"之指针
				对一个virtual member function取地址, 能获取的只是一个索引值, 在vptr的表中对应的索引值;
				编译器对指向member function的指针有两种处理方法:
					4.4.1.1) 使指针能够含有两种数值;
					4.4.1.2) 数值可以被区别代表内存地址还是Virtual Table中的索引值;
					实现方法:
						(((int)pmf) & ~127)
						?	// non-virtual invocation
						(*pmf)(ptr)
						:	// virtual invocation
						(*ptr->vptr[(int)pmf](ptr));
					缺陷: 假设最多只有128个virtual functions;
			4.4.2) 在多重继承下, 指向Member Functions指针
			使用特殊的结构使指向member functions的指针能够支持多重继承和虚拟继承:
			struct __mptr{
				int delta;	// 表示this指针的offset值;
				int index;	// virtual table 的索引, 当index不指向virtual table时, 会被设为-1;
				union{
					ptrtofunc faddr;	// nonvirtual member function的地址
					int v_offset;	// 在多重继承中的第二或后继的base class的vptr的位置;
				};
			};
			4.4.3) "指向Member Functions指针"的效率
	4.5) Inline Functions
		4.5.1) 处理inline函数的两个阶段:
			4.5.1.1) 分析函数定义, 以决定函数的"intrinsic inline ability"(本质的inline能力), 
												"intrinsic"(本质的, 固有的)一词在这里意指"与编译器相关"
			4.5.1.2) 真正的inline函数扩展操作是在调用的那一点上, 这会带来参数的求值操作(evaluation)以及临时性对象的管理;
		4.5.2) 形式参数(Formal Arguments)
			4.5.2.1) 面对"会带有副作用的实际参数", 在处理inline时会补充一个临时性对象:
												如果实际参数是一个常量表达式, 可以在替换之前先完成求值操作, 后继的
												inline替换, 就可以把常量直接"绑"上去;
												如果既不是常量表达式, 也不是带有副作用的表达式, 那么直接替换;
		4.5.3) 局部变量(Local Variables)
			

				

				





            


    
        
    
    



