Chapter2:

2.1) 线程管理基础:
	1) 需要在线程对象被析构前, 显示等待线程的完成, 或者分离它;

2.2） 
	1) 不可复制性保证了在同一时间点, 一个std::thread的实例只能关联一个执行线程;
	2) 可移动性是的程序员可以自己决定, 哪个实例拥有实际执行线程的所有权;

2.3) 转移线程的所有权:
	1) std::thread的临时对象进行赋值时, 会直接做隐式转移所有权的动作:<-|
		std::thread t1(some_function);																												|
		std::thread t2 = std::move(t1); t2是																		|
		std::thread t3 = std::move(t2);																											|
		t1 = std::thread(some_other_function);------------------->|
		t1 = std::move(t3); // 系统调用std::terminate()终止程序继续运行;
	
	void do_work(unsigned id);
	void f(){
		std::vector<std::thread> threads;
		for(unsigned i = 0; i < 20; i++){
			threads.push_back(std::thread(do_work, i));	// 产生线程;
		}
		std::for_each(threads.begin(), threads.end(), std::mem_fn(&std::thread::join));	// 对每个线程调用join()
	}

2.4) 运行时决定线程数量:
	1) 函数: std::thread::hardware_concurrency():
		1.1) 功能: 返回同时可并发在一个程序中的线程数量;
2.5) 标识线程:


Chapter3:
	3.1) 共享数据带来的问题:
		3.1.1) 条件竞争: 并发的去修改一个独立对象, 数据竞争是未定义行为的起因;
		3.1.2) 避免恶性条件竞争:
			1) 对数据结构采用某种保护机制;
				1.1) 可以使用C++标准库提供的互斥量实现, 但是有可能会出现死锁;
			2) 无锁编程;
			3) 使用事务处理数据结构的更新, 类似数据库中的事务;
		3.1.3) 使用互斥量保护共享数据;
	3.2) 使用互斥量保护共享数据:
		3.2.1) 互斥量保护的数据需要对接口的设计相当谨慎, 要确保互斥量能锁住任何对保护数据的访问, 并且不留后门;
		3.2.2) 不要把受保护数据的指针或者引用传递给互斥作用域之外, 无论是函数返回值, 还是存储在外部可见内存,
									亦或是以参数的形式传递到用户提供的函数中;
		3.2.3) 条件竞争: 共享的数据结构被互斥量所保护时, 接口的实现中存在返回结果不可靠性;
			1) std::is_nothrow_copy_constructible:	让拷贝构造函数不抛出异常; 
			2) std::is_nothrow_move_constructible:	让移动构造函数不抛出异常;
			3) 接口中条件竞争的解决方法:
				3.1) 传入一个引用+无异常抛出的构造拷贝函数或移动构造函数;
				3.2) 传入一个引用+返回指向弹出值的指针
				3.3) 
		3.2.4) 死锁:
			1) 避免死锁:
				1.1) 让两个互斥量总以相同的顺序上锁: 总在互斥量B之前锁住互斥量A;
				1.2) 避免嵌套锁: 一个线程已获得一个锁之后, 别再去获取第二个锁;
				1.3) 避免在持有锁时调用用户提供的代码;
				1.4) 使用固定顺序获取锁: 当需要获取两个以上的锁, 并且不能使用std::lock单独操作来获取它们;
				1.5) 使用锁的层次结构: 需要对应用进行分层, 并且识别在给定层上所有可上锁的互斥量;
									当代码视图对一个互斥量上锁, 在该层锁已被底层持有时, 上锁是不允许的;
				1.6) 超越锁的延伸扩展: 
		3.2.6) std::unique_lock
			1) 灵活的锁: 实例不带有互斥量, 信息已被存储, 且已被更新;
		3.2.7) 不同域中互斥量所有权的传递: 
		3.2.8) 锁的粒度:
			1) 锁的粒度: 描述一个锁保护着的数据量大小:
				1.1) 细粒度锁(a fine-grained lock): 能够保护较小的数据量;
				1.2) 粗粒度锁(a coarse-grained lock): 能够保护较多的数据量;
			2) 不需要让锁住的互斥量越过对process函数的调用, 要及时释放锁, 当再需要时上锁;
			3) 获取另外一个锁(即使知道这不会造成死锁), 或等待输入/输出操作完成时没有必要持有一个锁(除非绝对需要);
	3.3) 保护共享数据的替代设施:
		1) 延迟初始化: std::once_flag && std::call_once;
		2) 保护很少更新的数据结构: 使用std::shared_mutex做同步, 使用std::lock_guard<boost::shared_mutex>和
					std::unique_lock<boost::shared_mutex>进行上锁动作;
		3) 嵌套锁: 需要在同一个线程对同一个互斥量上多次锁, 可以使用std::recursive_mutex;
			3.1) 当进行了三次lock时, 需要做三次unlock;
			